"""
Signal Entity - Trading signal from strategy.

Path: src/python/domain/entities/signal.py
"""
from dataclasses import dataclass, field
from typing import Optional, Dict, Any
from decimal import Decimal
from datetime import datetime
from uuid import UUID, uuid4

from src.python.domain.value_objects.symbol import TradingPair


@dataclass
class Signal:
    """
    Signal entity representing a trading signal.
    
    Generated by strategies to indicate trading opportunities.
    """
    # Identity
    id: UUID = field(default_factory=uuid4)
    
    # Source
    strategy_name: Optional[str] = None
    
    # Signal details
    symbol: Optional[TradingPair] = None
    side: Optional[str] = None  # "BUY" or "SELL"
    timeframe: Optional[str] = None
    
    # Pricing recommendations
    entry_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    
    # Signal quality
    confidence: float = 0.0  # 0.0 to 1.0
    
    # Execution tracking
    executed: bool = False
    order_id: Optional[UUID] = None
    
    # Timestamps
    generated_at: datetime = field(default_factory=datetime.utcnow)
    
    # Additional metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal on creation."""
        if self.strategy_name is None:
            raise ValueError("Strategy name is required")
        if self.symbol is None:
            raise ValueError("Symbol is required")
        if self.side is None:
            raise ValueError("Side is required")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        
        # Ensure Decimal types only for non-Decimal inputs
        if self.entry_price is not None and not isinstance(self.entry_price, Decimal):
            object.__setattr__(self, 'entry_price', Decimal(str(self.entry_price)))
        if self.stop_loss is not None and not isinstance(self.stop_loss, Decimal):
            object.__setattr__(self, 'stop_loss', Decimal(str(self.stop_loss)))
        if self.take_profit is not None and not isinstance(self.take_profit, Decimal):
            object.__setattr__(self, 'take_profit', Decimal(str(self.take_profit)))
    
    def mark_executed(self, order_id: UUID) -> None:
        """
        Mark signal as executed.
        
        Args:
            order_id: ID of executed order
        """
        self.executed = True
        self.order_id = order_id
    
    def is_high_confidence(self, threshold: float = 0.7) -> bool:
        """
        Check if signal has high confidence.
        
        Args:
            threshold: Minimum confidence threshold
        
        Returns:
            True if confidence >= threshold
        """
        return self.confidence >= threshold
    
    def calculate_risk_reward_ratio(self) -> Optional[Decimal]:
        """
        Calculate risk/reward ratio.
        
        Returns:
            Risk/reward ratio or None if prices not set
        """
        if not all([self.entry_price, self.stop_loss, self.take_profit]):
            return None
        
        # Calculate risk (entry to stop loss)
        if self.side == "BUY":
            risk = abs(self.entry_price - self.stop_loss)
            reward = abs(self.take_profit - self.entry_price)
        else:
            risk = abs(self.stop_loss - self.entry_price)
            reward = abs(self.entry_price - self.take_profit)
        
        if risk == 0:
            return None
        
        return reward / risk
    
    def is_valid_risk_reward(self, min_ratio: Decimal = Decimal('1.5')) -> bool:
        """
        Check if signal has valid risk/reward ratio.
        
        Args:
            min_ratio: Minimum acceptable ratio
        
        Returns:
            True if ratio >= min_ratio
        """
        ratio = self.calculate_risk_reward_ratio()
        if ratio is None:
            return False
        
        return ratio >= min_ratio
    
    def __str__(self) -> str:
        """String representation."""
        return (
            f"Signal(id={self.id}, {self.strategy_name}: {self.symbol} {self.side} "
            f"entry={self.entry_price} sl={self.stop_loss} tp={self.take_profit} "
            f"confidence={self.confidence:.2f} executed={self.executed})"
        )
    
    def __repr__(self) -> str:
        """Detailed representation."""
        return self.__str__()