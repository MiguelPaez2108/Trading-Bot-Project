"""
Signal Entity - Trading signal representation.

Path: src/python/domain/entities/signal.py
"""
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional
from decimal import Decimal
from datetime import datetime, timezone
from uuid import UUID, uuid4

from src.python.domain.value_objects.symbol import TradingPair


class SignalType(str, Enum):
    """Signal type."""
    BUY = "BUY"
    SELL = "SELL"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"


class SignalStrength(str, Enum):
    """Signal strength/confidence."""
    WEAK = "WEAK"
    MEDIUM = "MEDIUM"
    STRONG = "STRONG"


@dataclass
class Signal:
    """
    Trading signal entity.
    
    Generated by strategies to indicate trading opportunities.
    """
    # Identity
    id: UUID = field(default_factory=uuid4)
    
    # Signal details
    symbol: Optional[TradingPair] = None
    signal_type: Optional[SignalType] = None
    strength: SignalStrength = SignalStrength.MEDIUM
    
    # Pricing
    price: Optional[Decimal] = None  # Price at signal generation
    target_price: Optional[Decimal] = None  # Target/take-profit
    stop_loss: Optional[Decimal] = None
    
    # Metadata
    strategy_name: Optional[str] = None
    timeframe: Optional[str] = None
    confidence: Decimal = Decimal('0.5')  # 0.0 to 1.0
    
    # Additional data
    indicators: dict = field(default_factory=dict)
    notes: Optional[str] = None
    
    # Timestamps
    generated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate signal on creation."""
        if self.symbol is None:
            raise ValueError("Symbol is required")
        if self.signal_type is None:
            raise ValueError("Signal type is required")
        if self.price is None or self.price <= 0:
            raise ValueError("Price must be positive")
        
        # Ensure Decimal types (runtime safety)
        if self.price is not None and not isinstance(self.price, Decimal):  # type: ignore[misc]
            object.__setattr__(self, 'price', Decimal(str(self.price)))
        if self.target_price is not None and not isinstance(self.target_price, Decimal):  # type: ignore[misc]
            object.__setattr__(self, 'target_price', Decimal(str(self.target_price)))
        if self.stop_loss is not None and not isinstance(self.stop_loss, Decimal):  # type: ignore[misc]
            object.__setattr__(self, 'stop_loss', Decimal(str(self.stop_loss)))
        if not isinstance(self.confidence, Decimal):  # type: ignore[misc]
            object.__setattr__(self, 'confidence', Decimal(str(self.confidence)))
    
    def is_buy(self) -> bool:
        """Check if signal is buy."""
        return self.signal_type == SignalType.BUY
    
    def is_sell(self) -> bool:
        """Check if signal is sell."""
        return self.signal_type == SignalType.SELL
    
    def is_close(self) -> bool:
        """Check if signal is close position."""
        return self.signal_type in [SignalType.CLOSE_LONG, SignalType.CLOSE_SHORT]
    
    def is_expired(self) -> bool:
        """Check if signal has expired."""
        if self.expires_at is None:
            return False
        return datetime.now(timezone.utc) > self.expires_at
    
    def risk_reward_ratio(self) -> Optional[Decimal]:
        """
        Calculate risk/reward ratio.
        
        Returns:
            Risk/reward ratio or None if not calculable
        """
        if self.target_price is None or self.stop_loss is None:
            return None
        
        if self.is_buy():
            risk = self.price - self.stop_loss  # type: ignore[operator]
            reward = self.target_price - self.price  # type: ignore[operator]
        else:
            risk = self.stop_loss - self.price  # type: ignore[operator]
            reward = self.price - self.target_price  # type: ignore[operator]
        
        if risk <= 0:
            return None
        
        return reward / risk
    
    def __str__(self) -> str:
        """String representation."""
        rr = self.risk_reward_ratio()
        rr_str = f"RR={rr:.2f}" if rr else ""
        
        return (
            f"Signal({self.signal_type.value} {self.symbol} @ {self.price} "
            f"strength={self.strength.value} confidence={self.confidence:.2f} {rr_str})"
        )
    
    def __repr__(self) -> str:
        """Detailed representation."""
        return self.__str__()